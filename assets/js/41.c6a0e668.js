(window.webpackJsonp=window.webpackJsonp||[]).push([[41],{463:function(_,v,t){"use strict";t.r(v);var a=t(2),l=Object(a.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h2",{attrs:{id:"八股小笔记-mysql"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#八股小笔记-mysql"}},[_._v("#")]),_._v(" 八股小笔记 -- MYSQL")]),_._v(" "),v("h3",{attrs:{id:"b树和b-树的区别-mysql为什么使用b-树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#b树和b-树的区别-mysql为什么使用b-树"}},[_._v("#")]),_._v(" B树和B+树的区别，Mysql为什么使用B+树")]),_._v(" "),v("h5",{attrs:{id:"b-树特点"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#b-树特点"}},[_._v("#")]),_._v(" B+树特点")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://img-blog.csdnimg.cn/c6c17473ef524cc5abbe377637638b8e.png",alt:"在这里插入图片描述"}})]),_._v(" "),v("ol",[v("li",[_._v("非叶子节点子树指针与关键字个数相同")]),_._v(" "),v("li",[_._v("所有叶子节点增加一个指针")]),_._v(" "),v("li",[_._v("叶子节点包含所有关键字")])]),_._v(" "),v("h5",{attrs:{id:"b-树优势"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#b-树优势"}},[_._v("#")]),_._v(" B+树优势")]),_._v(" "),v("ul",[v("li",[_._v("磁盘读写代价更低\n"),v("ul",[v("li",[_._v("B+树内部节点没有指向关键词的指针，内部节点更小")]),_._v(" "),v("li",[_._v("一次性读入内存需要查找的关键字越多，读写次数越小")])])]),_._v(" "),v("li",[_._v("查询效率更稳定\n"),v("ul",[v("li",[_._v("任何关键字的查找都是从根节点到子节点，由于所有叶子节点在同一层，so查询路径长度相同，使每个数据查询效率相当")])])]),_._v(" "),v("li",[_._v("便于范围查询\n"),v("ul",[v("li",[_._v("优化B树元素遍历效率低下的问题，其只需遍历叶子节点就可实现整棵树的遍历")])])])]),_._v(" "),v("h5",{attrs:{id:"mysql使用b-树"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mysql使用b-树"}},[_._v("#")]),_._v(" Mysql使用B+树")]),_._v(" "),v("ul",[v("li",[_._v("Mysql中MyIsAM和InnoDB采用B+树结构，前者是非聚集索引，后者是聚集索引")]),_._v(" "),v("li",[_._v("B+树节点只存储索引Key值，具体信息地址存于叶子节点中")]),_._v(" "),v("li",[_._v("Mysql中的InnoDB页是一个B+树节点，一个InnoDB页默认16kb，一般一颗两层的B+树可以存2000万行左右数据，可以很好支持全表扫描，范围查找等SQL语句")])]),_._v(" "),v("h5",{attrs:{id:"isam"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#isam"}},[_._v("#")]),_._v(" ISAM")]),_._v(" "),v("ul",[v("li",[_._v("索引顺序存取方法，可以按照进入顺序或根据索引访问，每个索引定义一次不同排列的记录")])]),_._v(" "),v("h5",{attrs:{id:"myisam"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#myisam"}},[_._v("#")]),_._v(" MyISAM")]),_._v(" "),v("ul",[v("li",[_._v("Mysql5.1之前的默认存储引擎，基于ISAM")]),_._v(" "),v("li",[_._v("每个MyISAM在磁盘存储成3个文件，都以表名开始")]),_._v(" "),v("li",[_._v("有三种文件类型\n"),v("ul",[v("li",[_._v(".frm -- 表定义")]),_._v(" "),v("li",[_._v(".MYD -- 表数据")]),_._v(" "),v("li",[_._v(".MYI -- 表索引")])])])]),_._v(" "),v("h5",{attrs:{id:"innodb"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#innodb"}},[_._v("#")]),_._v(" InnoDB")]),_._v(" "),v("ul",[v("li",[_._v("Mysql默认存储引擎，支持"),v("strong",[_._v("ACID")]),_._v("兼容的事务功能，类似于"),v("strong",[_._v("PostgreSQL")])]),_._v(" "),v("li",[_._v("有.frm存放元数据信息和表结构的定义信息")]),_._v(" "),v("li",[_._v(".ibd或.ibdata存放InnoDB数据，区别为是否共享表空间\n"),v("ul",[v("li",[_._v("独享用.ibd，每个表一个")]),_._v(" "),v("li",[_._v("共享用.ibdata，所有表共用一个")])])]),_._v(" "),v("li",[_._v("InnoDB事务采用两阶段提交模式:prepare,commit")])]),_._v(" "),v("h5",{attrs:{id:"myisam于innodb差别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#myisam于innodb差别"}},[_._v("#")]),_._v(" MyISAM于InnoDB差别")]),_._v(" "),v("ul",[v("li",[_._v("InnoDB支持事务，支持外键，MyISAM都不支持")]),_._v(" "),v("li",[_._v("InnoDB主键使用聚簇索引，辅助索引（在聚簇索引之上创建的索引）使用非聚簇索引，MyISAM都是非聚簇索引")]),_._v(" "),v("li",[_._v("InnoDB不保存表具体行数，查找数据需全表遍历")]),_._v(" "),v("li",[_._v("InnoDB最小锁粒度为行锁，比表锁粒度更小，避免查询和更新时被阻塞，导致并发访问受限")]),_._v(" "),v("li",[_._v("大数据量排序、全表扫描、count等操作，MyISAM更优")])]),_._v(" "),v("h3",{attrs:{id:"innodb是怎么实现事务的"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#innodb是怎么实现事务的"}},[_._v("#")]),_._v(" InnoDB是怎么实现事务的")]),_._v(" "),v("ul",[v("li",[_._v("概述："),v("a",{attrs:{href:"#InnoDB"}},[_._v("InnoDB概念")])])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://img-blog.csdnimg.cn/e1285871d10a473ca892cc0eff29dfc3.png",alt:"img"}})]),_._v(" "),v("ul",[v("li",[_._v("通过Buffer Pool, LogBuffer, Redo Log, Undo Log来实现事务\n"),v("ul",[v("li",[_._v("执行语句前，先缓存到Buffer Pool")]),_._v(" "),v("li",[_._v("之后修改Buffer Pool中数据")]),_._v(" "),v("li",[_._v("生成RedoLog对象，存入LogBuffer中")]),_._v(" "),v("li",[_._v("生成undoLog日志")]),_._v(" "),v("li",[_._v("若事务提交，则将RedoLog对象持久化，后利用其他机制持久化到磁盘中")]),_._v(" "),v("li",[_._v("若事务回滚，利用undoLog回滚")])])])]),_._v(" "),v("h5",{attrs:{id:"持久化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#持久化"}},[_._v("#")]),_._v(" 持久化")]),_._v(" "),v("ul",[v("li",[_._v("把域对象永久保存到数据库中")]),_._v(" "),v("li",[_._v("持久化封装了数据访问细节，提供api接口")]),_._v(" "),v("li",[_._v("利用持久化可以减少访问数据库次数，增加app运行速度")]),_._v(" "),v("li",[_._v("重用性高")]),_._v(" "),v("li",[_._v("耦合度低，不依赖底层数据库与上层业务逻辑实现，更换数据库不用修改代码")])]),_._v(" "),v("h2",{attrs:{id:"mysql索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mysql索引"}},[_._v("#")]),_._v(" MYSQL索引")]),_._v(" "),v("p",[_._v("通过索引对数据进行排序，降低数据排序的成本，（间接）降低CPU损耗")]),_._v(" "),v("h5",{attrs:{id:"mysql索引底层数据结构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mysql索引底层数据结构"}},[_._v("#")]),_._v(" Mysql索引底层数据结构")]),_._v(" "),v("p",[_._v("B+树")]),_._v(" "),v("ul",[v("li",[_._v("叶子节点存具体数据，非叶子节点存储指针（导航）")]),_._v(" "),v("li",[_._v("一个节点可有多个叶子节点，整体结构矮胖")]),_._v(" "),v("li",[_._v("叶子节点互相有双向链表，便于扫库")])]),_._v(" "),v("h5",{attrs:{id:"mysql聚簇索引与非聚簇索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mysql聚簇索引与非聚簇索引"}},[_._v("#")]),_._v(" Mysql聚簇索引与非聚簇索引")]),_._v(" "),v("ul",[v("li",[_._v("聚簇索引：将数据与索引放在一起，必须有且只能有一个\n"),v("ul",[v("li",[_._v("若存在主键，则该主键就是聚集索引")]),_._v(" "),v("li",[_._v("若不存在主键，将UNIQUE唯一索引作为聚集索引")]),_._v(" "),v("li",[_._v("都不存在，InnoDB自动生成rowId作为隐藏聚集索引")])])]),_._v(" "),v("li",[_._v("非聚簇索引（二级索引）：数据索引分开，叶子节点无数据，存储数据地址，可存在多个")])]),_._v(" "),v("h3",{attrs:{id:"回表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#回表"}},[_._v("#")]),_._v(" 回表")]),_._v(" "),v("p",[_._v("使用非聚簇索引，为取到具体数据，通过PK主键回到聚集索引去查询数据")]),_._v(" "),v("h3",{attrs:{id:"覆盖索引"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#覆盖索引"}},[_._v("#")]),_._v(" 覆盖索引")]),_._v(" "),v("p",[_._v("通过索引查询的数据，包含了所有要查询的数据，无需回表")]),_._v(" "),v("h3",{attrs:{id:"索引失效"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#索引失效"}},[_._v("#")]),_._v(" 索引失效")]),_._v(" "),v("ol",[v("li",[_._v("违反最左前缀法则：跳过最左字段匹配")]),_._v(" "),v("li",[_._v("范围查询右边的列")]),_._v(" "),v("li",[_._v("在索引列上进行运算操作（函数）")]),_._v(" "),v("li",[_._v("字符串不加''（类型转换）")]),_._v(" "),v("li",[_._v("头部模糊查询/头尾模糊查询")])]),_._v(" "),v("h3",{attrs:{id:"索引基本原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#索引基本原理"}},[_._v("#")]),_._v(" 索引基本原理")]),_._v(" "),v("ul",[v("li",[_._v("避免整张表遍历，将无序数据转为有序")]),_._v(" "),v("li",[_._v("对排序结果生成"),v("strong",[_._v("倒排表")])]),_._v(" "),v("li",[_._v("倒排表内容拼接数据地址链")]),_._v(" "),v("li",[_._v("查询时，先拿倒排表内容，再取数据地址，从而拿到数据")])]),_._v(" "),v("h5",{attrs:{id:"倒排表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#倒排表"}},[_._v("#")]),_._v(" 倒排表")]),_._v(" "),v("ul",[v("li",[_._v("有递增id的hash表，key为单词，value为该词数据的id")])]),_._v(" "),v("h2",{attrs:{id:"sql优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#sql优化"}},[_._v("#")]),_._v(" SQL优化")]),_._v(" "),v("h3",{attrs:{id:"表设计优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#表设计优化"}},[_._v("#")]),_._v(" 表设计优化")]),_._v(" "),v("p",[_._v("选择合适的数据类型")]),_._v(" "),v("h3",{attrs:{id:"sql语句优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#sql语句优化"}},[_._v("#")]),_._v(" SQL语句优化")]),_._v(" "),v("ol",[v("li",[_._v("避免使用SELECT *")]),_._v(" "),v("li",[_._v("避免造成"),v("a",{attrs:{href:"#%E7%B4%A2%E5%BC%95%E5%A4%B1%E6%95%88"}},[_._v("索引失效")])]),_._v(" "),v("li",[_._v("用UNION ALL代替UNION，避免UNION去重的多一次过滤")]),_._v(" "),v("li",[_._v("避免where语句中出现表达式操作（避免索引失效）")]),_._v(" "),v("li",[_._v("能用INNER JOIN 就不要用LEFT JOIN，（一定要用LEFT JOIN的情况，主表尽量为小表）")])]),_._v(" "),v("h3",{attrs:{id:"主从复制-读写分离"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#主从复制-读写分离"}},[_._v("#")]),_._v(" 主从复制/读写分离")]),_._v(" "),v("h4",{attrs:{id:"mysql主从集群"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mysql主从集群"}},[_._v("#")]),_._v(" MYSQL主从集群")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://img-blog.csdnimg.cn/20200713135335666.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTAxODU4MA==,size_16,color_FFFFFF,t_70",alt:"在这里插入图片描述"}})]),_._v(" "),v("ul",[v("li",[_._v("搭建MYSQL主从集群，主库实现写操作后记录到Binlog中，从库提取Binlog文件写入到从库的Relaylog中，实现主从数据同步")]),_._v(" "),v("li",[_._v("只能由主节点向从节点进行苏数据同步，过程异步，有数据丢失风险")]),_._v(" "),v("li",[_._v("可在传输过程中加入响应机制实现半同步复制，牺牲了一点点同步速度，保证数据安全性")])]),_._v(" "),v("h5",{attrs:{id:"并行复制-mts"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#并行复制-mts"}},[_._v("#")]),_._v(" 并行复制 MTS")]),_._v(" "),v("ul",[v("li",[_._v("MYSQL5.6之后为解决主从复制延迟而设计的功能")]),_._v(" "),v("li",[_._v("将从库两个线程IO Thread和SQL Thread的工作模式改为多线程机制\n"),v("ul",[v("li",[_._v("MYSQL5.6：基于库")]),_._v(" "),v("li",[_._v("MYSQL5.7：基于组（真正的并行复制），所有处于prepare阶段的事务互相不冲突，可并行提交,引入新变量slave-parallel-type,可以配置并行方式")]),_._v(" "),v("li",[_._v("MYSQL8.0：基于write-set，额外由一个集合变量存储事务修改的记录信息，提交时将记录打包成事务，将事务写入磁盘，提交事务将修改的主键值与集合变量对比，判断是否冲突，无冲突即并行，粒度达到row级别")])])])]),_._v(" "),v("h3",{attrs:{id:"分库分表"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#分库分表"}},[_._v("#")]),_._v(" 分库分表")]),_._v(" "),v("p",[_._v("垂直/水平拆分：分库/分表")]),_._v(" "),v("h3",{attrs:{id:"mysql慢查询"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mysql慢查询"}},[_._v("#")]),_._v(" MYSQL慢查询")]),_._v(" "),v("ul",[v("li",[_._v("顾名思义，查询SQL太慢")]),_._v(" "),v("li",[_._v("危害：\n"),v("ul",[v("li",[_._v("用户体验差、占内存影响性能、DDL操作阻塞")])])])]),_._v(" "),v("h5",{attrs:{id:"定位"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#定位"}},[_._v("#")]),_._v(" 定位")]),_._v(" "),v("ul",[v("li",[_._v("调试工具/运维工具（Skywalking)")]),_._v(" "),v("li",[_._v("MYSQL自带的慢查询日志\n"),v("ul",[v("li",[_._v("slow_query_log:配置慢查询日志")]),_._v(" "),v("li",[_._v("long_query_time:定义慢查询时间（一般为2s）")])])])]),_._v(" "),v("h5",{attrs:{id:"mysql慢查询优化"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mysql慢查询优化"}},[_._v("#")]),_._v(" Mysql慢查询优化")]),_._v(" "),v("p",[_._v("EXPLAIN/DESC命令：查看SELECT语句查询计划 （key：命中索引 ； key_len：索引占用大小；type:SQL连接类型；extra:是否出现回表情况）")]),_._v(" "),v("ol",[v("li",[_._v("聚合查询")]),_._v(" "),v("li",[_._v("多表查询")]),_._v(" "),v("li",[_._v("表数据量过大查询")]),_._v(" "),v("li",[_._v("深度分页查询")])]),_._v(" "),v("h6",{attrs:{id:"explain语句"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#explain语句"}},[_._v("#")]),_._v(" explain语句")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("key")]),_._v(" "),v("th",[_._v("含义")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("id")]),_._v(" "),v("td",[_._v("select的序列号，值越大优先值越高，某些子查询会被优化为join，id值相同")])]),_._v(" "),v("tr",[v("td",[_._v("select_type")]),_._v(" "),v("td",[_._v("对应查询类型"),v("br"),_._v("1.simple（简单select，不用union和子查询）"),v("br"),_._v("2.primary（包含复杂字部分）"),v("br"),_._v("3.union（union后的第二个和随后的select）"),v("br"),_._v("4.union result（union结果）"),v("br"),_._v("5.dependent union（外部查询之后，union后的第二个select）"),v("br"),_._v("6.subquery（子查询第一个select）"),v("br"),_._v("7.dependent subquery（外部查询之后，子查询第一个select）"),v("br"),_._v("8.deriver（派生表的select，FROM子句的子查询）"),v("br"),_._v("9.unCacheable subquery（表示查询结果不能被缓存）")])]),_._v(" "),v("tr",[v("td",[_._v("table")]),_._v(" "),v("td",[_._v("表名")])]),_._v(" "),v("tr",[v("td",[_._v("type")]),_._v(" "),v("td",[_._v("查询方式")])]),_._v(" "),v("tr",[v("td",[_._v("possible_keys")]),_._v(" "),v("td",[_._v("可能用到的索引")])]),_._v(" "),v("tr",[v("td",[_._v("Key")]),_._v(" "),v("td",[_._v("实际索引")])]),_._v(" "),v("tr",[v("td",[_._v("key_len")]),_._v(" "),v("td",[_._v("实际索引长度")])]),_._v(" "),v("tr",[v("td",[_._v("ref")]),_._v(" "),v("td",[_._v("连接匹配条件")])]),_._v(" "),v("tr",[v("td",[_._v("rows")]),_._v(" "),v("td",[_._v("预估记录条数")])]),_._v(" "),v("tr",[v("td",[_._v("Extra")]),_._v(" "),v("td",[_._v("额外信息")])])])]),_._v(" "),v("h5",{attrs:{id:"optimize-table整理碎片"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#optimize-table整理碎片"}},[_._v("#")]),_._v(" OPTIMIZE TABLE整理碎片")]),_._v(" "),v("ul",[v("li",[_._v("使用OPTIMIZE语句，MYSQL会锁定表")]),_._v(" "),v("li",[_._v("主要步骤：\n"),v("ol",[v("li",[_._v("检查，删除空闲空间与索引")]),_._v(" "),v("li",[_._v("重新组织表数据，使紧凑")]),_._v(" "),v("li",[_._v("优化表索引")]),_._v(" "),v("li",[_._v("更新表信息")])])]),_._v(" "),v("li",[_._v("用于消灭聚簇索引所带来的内存碎片")])]),_._v(" "),v("h2",{attrs:{id:"事务"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务"}},[_._v("#")]),_._v(" 事务")]),_._v(" "),v("h3",{attrs:{id:"事务的基本特性-acid"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务的基本特性-acid"}},[_._v("#")]),_._v(" 事务的基本特性 ACID")]),_._v(" "),v("ul",[v("li",[_._v("Atomic（原子性）：包含整个数据库，任意错都回滚")]),_._v(" "),v("li",[_._v("Consistency（一致性）：不能破坏关系数据完整性及业务逻辑一致性")]),_._v(" "),v("li",[_._v("Isolation（隔离性）：并发时，存在事务隔离")]),_._v(" "),v("li",[_._v("Durability（持久性）：事务成功结束，数据库更新需永久保存，且数据能恢复")])]),_._v(" "),v("h3",{attrs:{id:"脏读-不可重复读-幻读"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#脏读-不可重复读-幻读"}},[_._v("#")]),_._v(" 脏读，不可重复读，幻读")]),_._v(" "),v("p",[_._v("事务并发导致的“小”问题，可以加锁，事务隔离，MVCC来处理")]),_._v(" "),v("ul",[v("li",[_._v("脏读：读取未提交的数据。")]),_._v(" "),v("li",[_._v("不可重复读：同一个事务中多次执行同一个select, 读取到的数据"),v("strong",[_._v("发生了改变")]),_._v("（改数据）")]),_._v(" "),v("li",[_._v("幻读：同一个事务中多次执行同一个select, 读取到的数据"),v("strong",[_._v("行发生改变")]),_._v("（增删数据）")])]),_._v(" "),v("h3",{attrs:{id:"事务隔离级别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#事务隔离级别"}},[_._v("#")]),_._v(" 事务隔离级别")]),_._v(" "),v("ul",[v("li",[_._v("读未提交READ UNCOMMITTED (RU)：幻读，不可重复读和脏读均允许；")]),_._v(" "),v("li",[_._v("读已提交 READ COMMITTED (RC)：允许幻读和不可重复读，但不允许脏读")]),_._v(" "),v("li",[_._v("可重复读 REPEATABLE READ (RR)：允许幻读，但不允许不可重复读和脏读  （ "),v("strong",[_._v("MYSQL默认隔离级别")]),_._v(" ）")]),_._v(" "),v("li",[_._v("串行 SERIALIZABLE: 幻读，不可重复读和脏读都不允许")])]),_._v(" "),v("h3",{attrs:{id:"undo-log-redo-log"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#undo-log-redo-log"}},[_._v("#")]),_._v(" undo log/redo log")]),_._v(" "),v("p",[_._v("缓冲池buffer pool：将经常使用的数据，缓存到缓冲池")]),_._v(" "),v("p",[_._v("数据页page：InnoDB存储引擎磁盘管理的最小单元，每页默认16KB，页存储行数据")]),_._v(" "),v("ul",[v("li",[_._v("redo log\n"),v("ul",[v("li",[_._v("重做日志，记录数据页物理修改，实现事务持久性")]),_._v(" "),v("li",[_._v("在将日志刷新到磁盘的过程中有误，则需redo log日志进行恢复")])])]),_._v(" "),v("li",[_._v("undo log\n"),v("ul",[v("li",[_._v("回滚日志，逻辑日志，记录相反的指令，用于回滚，实现原子性和一致性")])])])]),_._v(" "),v("h3",{attrs:{id:"mysql锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mysql锁"}},[_._v("#")]),_._v(" mysql锁")]),_._v(" "),v("ul",[v("li",[_._v("按照锁粒度来划分可分为：行锁、表锁、全局锁")]),_._v(" "),v("li",[_._v("锁的作用顾名思义，行锁目前InnoDB支持，表锁MyISAM和InnoDB都支持")]),_._v(" "),v("li",[_._v("每种锁都含有共享锁和排他锁\n"),v("ul",[v("li",[_._v("共享锁（S）： 多事务可对同一个数据共享同一把锁，只读不能改")]),_._v(" "),v("li",[_._v("排他锁（X）：一事务一把锁，InnoDB会对增删改自动添加排他锁")])])]),_._v(" "),v("li",[_._v("表锁还额外加了一种意向锁，"),v("a",{attrs:{href:"#InnoDB%E6%84%8F%E5%90%91%E9%94%81"}},[_._v("InnoDB意向锁")])]),_._v(" "),v("li",[_._v("全局锁：Flush tables with read lock。加锁后整个数据库都只读，所有数据变更操作被挂起，一般用于全库备份")])]),_._v(" "),v("h4",{attrs:{id:"innodb意向锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#innodb意向锁"}},[_._v("#")]),_._v(" InnoDB意向锁")]),_._v(" "),v("ul",[v("li",[_._v("为支持多粒度锁而设计的表级锁，不与行锁和同级意向锁冲突")]),_._v(" "),v("li",[_._v("共分为意向共享锁（IS）与意向排他锁（IX）")]),_._v(" "),v("li",[_._v("为防止事务获取表数据时一行行判定是否锁定而产生的效率低下，实现了对应表的意向表锁，若锁被其他事务拿取，则可以直接去排队申请资源")]),_._v(" "),v("li",[_._v("冲突列表")])]),_._v(" "),v("table",[v("thead",[v("tr",[v("th"),_._v(" "),v("th",[_._v("意向共享锁(IS)")]),_._v(" "),v("th",[_._v("意向排他锁(IX)")]),_._v(" "),v("th",[_._v("表级共享锁(S)")]),_._v(" "),v("th",[_._v("表级排他锁(X)")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[v("strong",[_._v("意向共享锁(IS)")])]),_._v(" "),v("td",[v("strong",[_._v("兼容")])]),_._v(" "),v("td",[v("strong",[_._v("兼容")])]),_._v(" "),v("td",[v("strong",[_._v("兼容")])]),_._v(" "),v("td",[_._v("不兼容")])]),_._v(" "),v("tr",[v("td",[v("strong",[_._v("意向排他锁(IX)")])]),_._v(" "),v("td",[v("strong",[_._v("兼容")])]),_._v(" "),v("td",[v("strong",[_._v("兼容")])]),_._v(" "),v("td",[_._v("不兼容")]),_._v(" "),v("td",[_._v("不兼容")])]),_._v(" "),v("tr",[v("td",[v("strong",[_._v("表级共享锁(S)")])]),_._v(" "),v("td",[v("strong",[_._v("兼容")])]),_._v(" "),v("td",[_._v("不兼容")]),_._v(" "),v("td",[v("strong",[_._v("兼容")])]),_._v(" "),v("td",[_._v("不兼容")])]),_._v(" "),v("tr",[v("td",[v("strong",[_._v("表级排他锁(x)")])]),_._v(" "),v("td",[_._v("不兼容")]),_._v(" "),v("td",[_._v("不兼容")]),_._v(" "),v("td",[_._v("不兼容")]),_._v(" "),v("td",[_._v("不兼容")])])])]),_._v(" "),v("h3",{attrs:{id:"mysql-的mvcc"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#mysql-的mvcc"}},[_._v("#")]),_._v(" MYSQL 的MVCC")]),_._v(" "),v("ul",[v("li",[_._v("名为多版本并发控制，读写隔离，使读写操作没有冲突")]),_._v(" "),v("li",[_._v("修改同一条数据时，会在undo log日志中，记录一条记录版本链表，每条数据含回滚版本号，版本id等")]),_._v(" "),v("li",[_._v("readView（当前读）\n"),v("ul",[v("li",[_._v("每次查询加锁，势必拿到最新数据")])])]),_._v(" "),v("li",[_._v("readView（快照读）\n"),v("ul",[v("li",[_._v("在开始事务时创建readView，以数组形式记录活动事务（未提交事务）的事务id")]),_._v(" "),v("li",[_._v("访问数据时，比对readview中的id，若比readview都小，则可以访问，若比readview都大，则不可访问，若在readview中，则获取roll_pointer,取上一版本，再来一次上述操作")]),_._v(" "),v("li",[_._v("RC隔离级别下的事务每次查询前都生成新的readview；RR级别下的readview可复用；序列级别：快照读退化为当前读")])])])])])}),[],!1,null,null,null);v.default=l.exports}}]);